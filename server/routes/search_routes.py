# server/routes/search_routes.py
"""Search routes with proper cache key hashing"""

from fastapi import APIRouter, HTTPException, Query, Depends
from pydantic import BaseModel
from typing import Optional
from qdrant_client import QdrantClient
from services.embedding_api_client import EmbeddingAPIClient
from core.logger import get_logger
from middleware.cache_decorator import cache_endpoint_with_body
from services.cache_key_generator import CacheKeyGenerator

logger = get_logger(__name__)
router = APIRouter(prefix="/api/search", tags=["search"])

QDRANT_URL = "http://qdrant:6333"
QDRANT_API_KEY = "qdrant_secure_key_123"


class SearchRequest(BaseModel):
    """Search request with query and parameters"""
    query: str
    limit: int = 5
    threshold: float = 0.5
    company_id: Optional[str] = None


@router.post("/tickets/similar")
@cache_endpoint_with_body(
    ttl=120,
    tag="search:similar",
    key_params=["company_id"],
    request_body_fields=["query", "limit", "threshold"],
    endpoint_name="search_similar_tickets"
)
async def search_similar_tickets(request: SearchRequest):
    """
    Search for similar tickets with intelligent cache key hashing
    
    Cache key includes:
    - company_id (if provided)
    - Hash of query + limit + threshold
    - TTL: 120 seconds
    
    Example cache key:
    "endpoint:search_similar_tickets:company_id-abc123:body-a1b2c3d4"
    """
    try:
        # Generate embedding for query
        embedding_client = EmbeddingAPIClient()
        query_vector = embedding_client.get_embedding_vector(request.query)
        
        if not query_vector:
            raise HTTPException(status_code=400, detail="Failed to generate query embedding")
        
        # Search in Qdrant
        qdrant_client = QdrantClient(url=QDRANT_URL, api_key=QDRANT_API_KEY)
        results = qdrant_client.search(
            collection_name="tickets",
            query_vector=query_vector,
            limit=request.limit,
            score_threshold=request.threshold
        )
        
        # Format results
        formatted_results = []
        for result in results:
            formatted_results.append({
                "similarity_score": result.score,
                "embedding_id": result.payload.get("embedding_id"),
                "ticket_id": result.payload.get("ticket_id"),
                "source_type": result.payload.get("source_type"),
                "text": result.payload.get("text")
            })
        
        logger.info(f"Found {len(formatted_results)} similar tickets for query: {request.query}")
        
        return {
            "query": request.query,
            "total_results": len(formatted_results),
            "results": formatted_results
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Search failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/tickets/similar-by-query")
async def search_by_query_string(
    query: str = Query(..., min_length=3, description="Search query"),
    limit: int = Query(5, ge=1, le=20),
    threshold: float = Query(0.5, ge=0, le=1),
    company_id: Optional[str] = Query(None)
):
    """
    Alternative search endpoint using query string parameters
    
    Cache key is generated by hashing the query string itself
    """
    try:
        # Generate query hash for caching
        query_hash = CacheKeyGenerator.generate_from_query_string(
            query,
            normalize=True  # Normalize to catch variations
        )
        
        # Manually create cache key
        cache_key_parts = ["search:by_query", f"limit-{limit}", f"threshold-{threshold}"]
        if company_id:
            cache_key_parts.insert(1, f"company-{company_id}")
        cache_key = CacheKeyGenerator.build_cache_key(
            "search:by_query",
            f"company-{company_id}" if company_id else None,
            f"limit-{limit}",
            f"threshold-{threshold}",
            hash_value=query_hash
        )
        
        # Try cache
        cache = await get_cache()
        cached = await cache.get(cache_key)
        if cached:
            logger.debug(f"Cache HIT: {cache_key}")
            return cached
        
        # Not cached, perform search
        embedding_client = EmbeddingAPIClient()
        query_vector = embedding_client.get_embedding_vector(query)
        
        if not query_vector:
            raise HTTPException(status_code=400, detail="Failed to generate query embedding")
        
        qdrant_client = QdrantClient(url=QDRANT_URL, api_key=QDRANT_API_KEY)
        results = qdrant_client.search(
            collection_name="tickets",
            query_vector=query_vector,
            limit=limit,
            score_threshold=threshold
        )
        
        formatted_results = [
            {
                "similarity_score": r.score,
                "embedding_id": r.payload.get("embedding_id"),
                "ticket_id": r.payload.get("ticket_id"),
                "source_type": r.payload.get("source_type"),
                "text": r.payload.get("text")
            }
            for r in results
        ]
        
        result = {
            "query": query,
            "total_results": len(formatted_results),
            "results": formatted_results
        }
        
        # Cache result
        await cache.set(
            key=cache_key,
            value=result,
            ttl=120,
            tags=["search:by_query", "search:*"]
        )
        
        logger.info(f"Found {len(formatted_results)} results for query: {query}")
        return result
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Search failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# Import cache for the alternative endpoint
from services.redis_cache_service import get_cache